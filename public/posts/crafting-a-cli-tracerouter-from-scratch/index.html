<!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta
    name="description"
    content="Author: Kien Nguyen <kiennt2609@gmail.com>
      A minimal Hugo theme with Tailwind CSS"
  />
    <title>
    
        wnccys 
    </title>
  <meta name="author" content="map[email:wnccys@proton.me name:Vinicius de Souza]" />
  <meta name="description" content="" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <link
    rel="icon"
    href="/favicon_io/favicon.ico"
    type="image/x-icon"
  />
  <link
    rel="icon"
    href="/favicon_io/favicon-16x16.png"
    size="16x16"
    type="image/png"
  />
  <link
    rel="icon"
    href="/favicon_io/favicon-32x32.png"
    size="32x32"
    type="image/png"
  />

  <link
    rel="preload"
    type="text/css"
    href="/css/rose-pine.min.css"
    integrity=""
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript>
    <link
      rel="stylesheet"
      type="text/css"
      href="/css/rose-pine.min.css"
      integrity=""
    />
  </noscript>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Manrope:wght@200..800&display=swap" rel="stylesheet"><link
    rel="preload"
    type="text/css"
    href="/css/toigian.css"
    integrity=""
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript>
    <link
      rel="stylesheet"
      type="text/css"
      href="/css/toigian.css"
      integrity=""
    />
  </noscript>

  
  <link
    rel="stylesheet"
    type="text/css"
    href="/css/light.css"
    integrity=""
  />
  <link
    rel="stylesheet"
    type="text/css"
    href="/css/dark.css"
    integrity=""
  />

  <script>
    
    if (
      localStorage.theme === "dark" ||
      (!("theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches)
    ) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  </script>

  
  
  <script
    async
    defer
    src="/js/main.js"
    integrity=""
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({ startOnLoad: true, securityLevel: "loose" });
  </script>
  
  
</head>
<body><header style="--layer: 10">
  <div
    aria-hidden="true"
    class="absolute top-[-1000px] left-0 z-[calc(var(--layer)+1)] h-[calc(1000px+var(--page-top))] w-full bg-base"
  ></div>

  <div
    class="fixed top-0 left-0 z-[var(--layer)] flex h-header-height w-full items-center px-page-gutter before:absolute before:inset-0 before:z-[-1] before:bg-base [@supports(backdrop-filter:blur(0))]:before:bg-base [@supports(backdrop-filter:blur(0))]:before:backdrop-blur-md"
  ><div
  class="lowercase italic mx-auto flex w-full max-w-content items-center justify-between"
  style="flex-wrap: nowrap;" 
>
  <nav class="mr-3" style="flex: 1; min-width: 0; overflow: hidden; white-space: nowrap;">
    <ol class="flex text-md items-center">
      
  
    
  
    
  
  
  
  
  
    <li>
      
      
      <a href="/" class="text-muted focus:underline focus:outline-none pr-1 whitespace-nowrap">wnccys</a>
    </li>
    <li class="text-muted focus:underline focus:outline-none pr-1 whitespace-nowrap">/</li>
  

  
  
  
  
  
    <li>
      
      
      <a href="/posts/" class="text-muted focus:underline focus:outline-none pr-1 whitespace-nowrap">Posts</a>
    </li>
    <li class="text-muted focus:underline focus:outline-none pr-1 whitespace-nowrap">/</li>
  

  
  
  
  
  
    <li style="min-width: 0; flex: 1;">
      
      
      <a href="/posts/crafting-a-cli-tracerouter-from-scratch/" 
         class="focus:underline focus:outline-none font-bold pr-1 hidden md:block"
         style="display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
         Crafting a CLI Tracerouter from Scratch
      </a>
    </li>
  

    </ol>
  </nav>

  <nav class="ml-3" style="flex-shrink: 0;">
    <ul class="flex text-sm whitespace-nowrap">
      
        <li class="pl-2">
          <a href="/about" class="tracking-wide hover:underline text-wrap">
             About
            </a>
        </li>
      
        <li class="pl-2">
          <a href="/posts" class="tracking-wide hover:underline text-wrap">
             Posts
            </a>
        </li>
      
        <li class="pl-2">
          <a href="/now" class="tracking-wide hover:underline text-wrap">
             Now
            </a>
        </li>
      
        <li class="pl-2">
          <a href="/tags" class="tracking-wide hover:underline text-wrap">
             Tags
            </a>
        </li>
      
        <li class="pl-2">
          <a href="/contact" class="tracking-wide hover:underline text-wrap">
             Contact
            </a>
        </li>
      
    </ul>
  </nav>
</div>
</div>
</header>
<main class="flex justify-center px-page-gutter py-page-top">
      <div class="min-h-content w-full max-w-content space-y-10 sm:space-y-20"><div
  class="lowercase italic mx-auto flex w-full max-w-content items-center justify-between"
  style="flex-wrap: nowrap;" 
>
  <nav class="mr-3" style="flex: 1; min-width: 0; overflow: hidden; white-space: nowrap;">
    <ol class="flex text-md items-center">
      
  
    
  
    
  
  
  
  
  
    <li>
      
      
      <a href="/" class="text-muted focus:underline focus:outline-none pr-1 whitespace-nowrap">wnccys</a>
    </li>
    <li class="text-muted focus:underline focus:outline-none pr-1 whitespace-nowrap">/</li>
  

  
  
  
  
  
    <li>
      
      
      <a href="/posts/" class="text-muted focus:underline focus:outline-none pr-1 whitespace-nowrap">Posts</a>
    </li>
    <li class="text-muted focus:underline focus:outline-none pr-1 whitespace-nowrap">/</li>
  

  
  
  
  
  
    <li style="min-width: 0; flex: 1;">
      
      
      <a href="/posts/crafting-a-cli-tracerouter-from-scratch/" 
         class="focus:underline focus:outline-none font-bold pr-1 hidden md:block"
         style="display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
         Crafting a CLI Tracerouter from Scratch
      </a>
    </li>
  

    </ol>
  </nav>

  <nav class="ml-3" style="flex-shrink: 0;">
    <ul class="flex text-sm whitespace-nowrap">
      
        <li class="pl-2">
          <a href="/about" class="tracking-wide hover:underline text-wrap">
             About
            </a>
        </li>
      
        <li class="pl-2">
          <a href="/posts" class="tracking-wide hover:underline text-wrap">
             Posts
            </a>
        </li>
      
        <li class="pl-2">
          <a href="/now" class="tracking-wide hover:underline text-wrap">
             Now
            </a>
        </li>
      
        <li class="pl-2">
          <a href="/tags" class="tracking-wide hover:underline text-wrap">
             Tags
            </a>
        </li>
      
        <li class="pl-2">
          <a href="/contact" class="tracking-wide hover:underline text-wrap">
             Contact
            </a>
        </li>
      
    </ul>
  </nav>
</div>
<article>
  <h1>Crafting a CLI Tracerouter from Scratch</h1>
  
  



    <div class="date-container"><time
  datetime="2025/11/25"
  class="mr-1 text-sm italic tabular-nums text-muted"
  >2025/11/25&nbsp;</time
>

    </div>


  

  
    <div class="section">
      
        
        <a href="/tags/rust/" id="tag">Rust</a>
      
        
        <a href="/tags/network/" id="tag">Network</a>
      
        
        <a href="/tags/cli/" id="tag">Cli</a>
      
        
        <a href="/tags/sockets/" id="tag">Sockets</a>
      
        
        <a href="/tags/windows/" id="tag">Windows</a>
      
        
        <a href="/tags/tutorial/" id="tag">Tutorial</a>
      
    </div>
  


<div id="toc">
  
    
      <details open>
        <summary>Table of contents</summary>
        <div id="toc-list"><nav id="TableOfContents">
  <ul>
    <li><a href="#but-what-is-a-socket">But, what is a Socket?</a></li>
    <li><a href="#what-about-icmp-why">What about ICMP? Why?</a></li>
    <li><a href="#how-we-are-going-to-make-it-exactly">How we are going to make it exactly?</a></li>
    <li><a href="#tools-used-in-the-tutorial">Tools used in the tutorial</a></li>
    <li><a href="#setting-up-our-environment">Setting up our Environment</a></li>
    <li><a href="#parsing-ips">Parsing IPs</a></li>
    <li><a href="#creating-our-own-socket">Creating our own Socket</a>
      <ul>
        <li><a href="#the-ip-header-structure">The IP Header Structure</a></li>
        <li><a href="#getting-our-local-ip">Getting our local IP</a></li>
        <li><a href="#the-icmp-packet">The ICMP Packet</a></li>
        <li><a href="#allowing-icmp-ttl-expired-packet-on-windows">Allowing ICMP TTL Expired Packet on Windows</a></li>
      </ul>
    </li>
    <li><a href="#sending-our-packet">Sending Our Packet</a></li>
  </ul>
</nav></div>
      </details>
    
  
</div>

<style>
     
    #toc-list *,
    #TableOfContents * {
        list-style: none !important;       
        list-style-type: none !important;  
    }

     
    #toc-list *:before,
    #TableOfContents *:before,
    #toc-list *:after,
    #TableOfContents *:after {
        content: "" !important;
        content: none !important;
        display: none !important;
    }

     
    #toc-list li::marker,
    #TableOfContents li::marker {
        content: "" !important;
        display: none !important;
        font-size: 0 !important;
    }

     
    #toc-list ul,
    #TableOfContents ul {
        padding-left: 0 !important;
        margin-left: 0 !important;
    }

     
    .anchor-link {
        opacity: 0;            
        text-decoration: none;
        color: #888;           
        margin-left: 0.5rem;   
        transition: opacity 0.2s ease-in-out;
    }

     
    h1:hover .anchor-link,
    h2:hover .anchor-link,
    h3:hover .anchor-link,
    h4:hover .anchor-link,
    h5:hover .anchor-link,
    h6:hover .anchor-link {
        opacity: 1;            
    }
</style><div class="content"><p>In this tutorial, we’re going to make an CLI Tracerouter which uses a ICMP packet request approach, since the Raw Socket creation until the entire trace itself, what gives us a great vision of how requests are made and sent over the Internet, as well as we crafting our own Checksum function! Don’t get too hung up on these terms right now, the article is made to instruct first-way people who are interested in understanding the Internet deeper as well as the experienced ones.</p>
<!-- raw HTML omitted -->
<p>NOTE: The title doesn’t specify a language, the tutorial is written in Rust but it’s focus in on concepts, what makes it’s content suitable to be written in basically any language programming of your choice with sockets support !!</p>
<!-- raw HTML omitted -->
<h2 id="but-what-is-a-socket" class="group relative">
  But, what is a Socket?

  
      <a href="#but-what-is-a-socket" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h2><p>A Socket is a specific structure — basically a pattern, which interface with the computer network hardware API itself <em>(This API is OS specific, but in our case, socket2 crate handle this for us)</em>; What means when we make any kind of request we are using Sockets in some way, which handles a lot of things for us. In this tutorial we’re going to use them to make our Tracerouter using ICMP request but specifically using <em>Raw Sockets</em>, which are a even low-level kind of Socket; It is like a <em>Primitive Socket</em> that allow we to craft our own packets !!</p>
<h2 id="what-about-icmp-why" class="group relative">
  What about ICMP? Why?

  
      <a href="#what-about-icmp-why" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h2><p>ICMP is another packet type like UDP or TCP and stands for Internet Control Message Protocol which offer us a standard way to inform network status/errors over the Internet, what is a lot handy once we want to discover the network until our target server.</p>
<p>The Internet acts like a large graph of routers! where each router forward the request to the next until our target server is reached; In this tutorial specifically we’re going to explore the layer 3 and 4 of the Internet whose are respectively the internet and the transport layers conventionally; This way the Internet works allow us to probe our network by sending specific packets (ICMP’s in our case) by testing them by try-error.</p>
<p>The ICMP choice isn’t random, we can probe our network by manipulating the IP Header TTL property and get a error report back to us. This property tell to routers the lifetime of the packet, when TTL 0 is reach that means the packet is invalid, and a error message are hopefully sent back to us:</p>
<p><img src="image.png" alt="image.png"></p>
<!-- raw HTML omitted -->
<p>NOTE: Hopefully in this case is because as we are dealing with strange routers, some of them can behavior different from what we expect; Like returning nothing when TTL reach 0, so it is interesting to test with many different target addresses to check they behavior.</p>
<!-- raw HTML omitted -->
<p>Talking deeper about TTL, it is specified on the IP header, which is the layer responsible to find our target server across the Internet. The TTL count is decreased in every router it hops and is send further to the next router; When TTL reach 0 the packet is expired, them we use the error returned to get information about the network making the calls successively each one increasing the TTL count by one.</p>
<p><img src="image%201.png" alt="Image from Berkeley’s University CS168: https://sp25.cs168.io/."></p>
<p>Image from Berkeley’s University CS168: <a href="https://sp25.cs168.io/">https://sp25.cs168.io/</a>.</p>
<h2 id="how-we-are-going-to-make-it-exactly" class="group relative">
  How we are going to make it exactly?

  
      <a href="#how-we-are-going-to-make-it-exactly" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h2><p>Our Tracerouter will take advantage of how TTL works and will probe the IP’s sending various waves of TTL increasing progressivelly they count until we find our target server; First we need a Socket, in our case we’re going to use a special type of Socket as mentioned earlier, a <em>Raw Socket; After, we’re going to craft our own IP and ICMP headers! IP acts like a wrapper around the ICMP header, and once the IP layer find our target, the header are parsed and removed, this way:</em></p>
<p><img src="image%202.png" alt="image.png"></p>
<h2 id="tools-used-in-the-tutorial" class="group relative">
  Tools used in the tutorial

  
      <a href="#tools-used-in-the-tutorial" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h2><p>[Language]</p>
<p>Rust</p>
<p>[Crates]</p>
<p>local-ip-address —&gt; Util which takes local IP dynamically.</p>
<p>dns-lookup —&gt; Resolve CLI given domain name.</p>
<p>socket2 —&gt; Network Socket API.</p>
<h2 id="setting-up-our-environment" class="group relative">
  Setting up our Environment

  
      <a href="#setting-up-our-environment" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h2><p>In this tutorial, we’re going to use the socket2 crate which gives us a lot of utils when leading with sockets and raw protocols. But first, we create our project:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; cargo new tracerouter
</span></span><span class="line"><span class="cl">&gt; <span class="nb">cd</span> tracerouter
</span></span></code></pre></div><p>Next, when specify the socket2 crate in our Cargo.toml:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">socket2</span> <span class="p">=</span> <span class="s2">&#34;0.5&#34;</span>
</span></span></code></pre></div><p>And create a tracerouter folder with it’s mod.rs file where we’ll store our logic to be called in main.rs so the workspace should be like:</p>
<p><img src="image%203.png" alt="image.png"></p>
<!-- raw HTML omitted -->
<p>NOTE: When running the project, as we are dealing with a low-level abstraction of Sockets, root privilege should be granted to the process so it can run properly.</p>
<!-- raw HTML omitted -->
<p>And now our project are good to start.</p>
<h2 id="parsing-ips" class="group relative">
  Parsing IPs

  
      <a href="#parsing-ips" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h2><p>Before we create our Socket, our CLI first need to be able to accept line arguments as well as resolve domains using a DNS so we can use human-readable string (like <a href="http://google.com/">google.com</a> instead of 8.8.8.8) so we’re going to make this checking and validating arguments and using the dns-lookup crate:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">env</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">args</span><span class="p">().</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;Usage: tracerouter &lt;hostname&gt;&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Tracing route to: </span><span class="si">{}</span><span class="s">...&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This code reads the executable arguments and check if the hostname argument is present in program call, if not, it prints an error and finish the program process;</p>
<p>After that, we set a util function to resolve our hostname into it’s IPV4 address using the dns_lookup crate in <em>mod.rs</em>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="k">mod</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">IpAddr</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">dns_lookup</span>::<span class="n">lookup_host</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// Lookup host and return a list of valid IPV4-only addresses.
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">resolve_host</span><span class="p">(</span><span class="n">hostname</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">IpAddr</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">lookup_host</span><span class="p">(</span><span class="n">hostname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">ips</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ips</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">ip</span><span class="o">|</span><span class="w"> </span><span class="n">ip</span><span class="p">.</span><span class="n">is_ipv4</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">IpAddr</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;Could not find valid IPs for </span><span class="si">{hostname}</span><span class="s">, </span><span class="si">{e}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This code take our hostname and search for it’s IPs and exits when no valid IPV4 address is found. Here, we just looked up into a very important network concept: Domain Name Servers which are servers present all over the Internet which gives us the correctIP representation given a hostname.</p>
<p>Now we call the function:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w"> </span><span class="n">After</span><span class="w"> </span><span class="n">route</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="w"> </span><span class="n">feedback</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">tracerouter</span>::<span class="n">resolve_host</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Tracing route to: </span><span class="si">{}</span><span class="s">...&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ips</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resolve_host</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">ips</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;Error: Could not find IP for </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="creating-our-own-socket" class="group relative">
  Creating our own Socket

  
      <a href="#creating-our-own-socket" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h2><p>Now, in order to finally create our Socket we’re going to initialize it’s structure and specifying we are setting the IP Header manually without passing throught system network-layer processing:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">socket2</span>::<span class="p">{</span><span class="n">Domain</span><span class="p">,</span><span class="w"> </span><span class="n">Protocol</span><span class="p">,</span><span class="w"> </span><span class="n">Socket</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Create our IPV4 Socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Socket</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Domain</span>::<span class="no">IPV4</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Type</span>::<span class="no">RAW</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">Protocol</span>::<span class="no">ICMPV4</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Error: Could not initialize Socket.
</span></span></span><span class="line"><span class="cl"><span class="s">    It is required for program to be running in a high privilege state.&#34;</span><span class="p">);</span><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Specify to kernel we&#39;re sending our own IP header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// If false, system will take care of it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">socket</span><span class="p">.</span><span class="n">set_header_included_v4</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Could not specify IP_HDRINCL header.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>This creates our Socket and specify which protocol we’re going to use (ICMPV4 for ICMP requests using IPV4).</p>
<p>Next, we need to craft the IP and ICMP headers as our project will work with 3 different structures:</p>
<p><strong>IP Header</strong> (20 bytes without options):
• Contains fields like version, length, protocol, source/destination IPs, and a checksum.</p>
<p><strong>ICMP Header</strong> (8 bytes for an Echo Request):
• Includes type, code, checksum, identifier, and sequence number.</p>
<p><strong>Data</strong> (optional): We’ll omit this for simplicity, making the total packet size 20 + 8 = 28 bytes.</p>
<h3 id="the-ip-header-structure" class="group relative">
  The IP Header Structure

  
      <a href="#the-ip-header-structure" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h3><p>The IP Packet is also a convention as well as ICMP (as well as all Protocols) so we need to follow the pattern below so our IP Header get correctly interpreted by the destination:</p>
<table>
  <thead>
      <tr>
          <th><strong>Offset (Bytes)</strong></th>
          <th><strong>Field</strong></th>
          <th><strong>Size</strong></th>
          <th><strong>Value</strong></th>
          <th><strong>Description</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>Version + IHL</td>
          <td>1 byte</td>
          <td>0x45</td>
          <td>Version 4 (4 bits), IHL 5 (4 bits, 5*4=20 bytes)</td>
      </tr>
      <tr>
          <td>1</td>
          <td>Type of Service (ToS)</td>
          <td>1 byte</td>
          <td>0</td>
          <td>Default QoS (0)</td>
      </tr>
      <tr>
          <td>2-3</td>
          <td>Total Length</td>
          <td>2 bytes</td>
          <td>28</td>
          <td>IP header (20) + ICMP header (8), big-endian</td>
      </tr>
      <tr>
          <td>4-5</td>
          <td>Identification</td>
          <td>2 bytes</td>
          <td>0</td>
          <td>Unique packet ID (0 for simplicity)</td>
      </tr>
      <tr>
          <td>6-7</td>
          <td>Flags + Fragment Offset</td>
          <td>2 bytes</td>
          <td>0</td>
          <td>No fragmentation (0)</td>
      </tr>
      <tr>
          <td>8</td>
          <td>Time to Live (TTL)</td>
          <td>1 byte</td>
          <td>64</td>
          <td>Hop limit</td>
      </tr>
      <tr>
          <td>9</td>
          <td>Protocol</td>
          <td>1 byte</td>
          <td>1</td>
          <td>ICMP protocol number</td>
      </tr>
      <tr>
          <td>10-11</td>
          <td>Header Checksum</td>
          <td>2 bytes</td>
          <td>(Calculated)</td>
          <td>Checksum over IP header, big-endian</td>
      </tr>
      <tr>
          <td>12-15</td>
          <td>Source IP Address</td>
          <td>4 bytes</td>
          <td>e.g., 192.168.1.100</td>
          <td>Source IP in byte form</td>
      </tr>
      <tr>
          <td>16-19</td>
          <td>Destination IP Address</td>
          <td>4 bytes</td>
          <td>e.g., 8.8.8.8</td>
          <td>Destination IP in byte form</td>
      </tr>
  </tbody>
</table>
<p>To craft our own IP Header object we’re going to write manually the bits to it using Buffers, which are nothing more than arrays of bytes and as our IP Header are 20 bytes long, we’re going to make it this way:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">packet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span><span class="w"> </span><span class="c1">// IP Header (20 bytes) + ICMP (8 bytes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// IP Header (simplified, version 4, no options)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// First 4 bits are the version (4) and the preceding 4 bits IHL (5) (big-endian represented)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x45</span><span class="p">;</span><span class="w">                        </span><span class="c1">// Version: 4, IHL: 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// packet[1] = 0;                        // ToS omitted because bucket is already 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                          </span><span class="c1">// High Byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">28</span><span class="p">;</span><span class="w">                         </span><span class="c1">// Low Byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">6</span><span class="p">].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="k">u16</span><span class="p">.</span><span class="n">to_be_bytes</span><span class="p">());</span><span class="w"> </span><span class="c1">// Identification (0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">8</span><span class="p">].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="k">u16</span><span class="p">.</span><span class="n">to_be_bytes</span><span class="p">());</span><span class="w"> </span><span class="c1">// Flags + Fragment Offset (0 unspecified)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// packet[8] = 4;                       // TTL (Late populated)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                          </span><span class="c1">// Protocol (ICMP)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    
</span></span></span><span class="line hl"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="getting-our-local-ip" class="group relative">
  Getting our local IP

  
      <a href="#getting-our-local-ip" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h3><p>But, what about our own IP Address? How are we supposed to set it? That’s what we’re going to discover now: Using the local_ip_address crate, we’ll be able to get our IPV4:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	
</span></span></span><span class="line hl"><span class="cl"><span class="w">	  </span><span class="k">if</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_empty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">	      </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;Usage: tracerouter &lt;hostname&gt;&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">	      </span><span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">	  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">	  </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Tracing route to: </span><span class="si">{}</span><span class="s">...&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="kd">let</span><span class="w"> </span><span class="n">my_ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">local_ip</span><span class="p">().</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Could not get local IP.&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><p>This make sure our local IPV4 IP Address are available while using our application, and with this we can set the address to our packet:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">	  </span><span class="n">packet</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">                          </span><span class="c1">// TTL
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">	  </span><span class="n">packet</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                          </span><span class="c1">// Protocol (ICMP)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="kd">let</span><span class="w"> </span><span class="n">my_ip_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_ip</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">my_num_ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_ip_str</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="c1">// Set local IP Address to packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	  </span><span class="k">for</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">12</span><span class="o">..=</span><span class="mi">15</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	      </span><span class="n">packet</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_num_ip</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><p>Next, as the destination domain can have multiple addresses (as we can see in the return of resolve_host()), we’re going to iterate over each one, until some is valid:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="cm">/* After set our IP code to packet */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Uses each destination IP address to until an request is successfully completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">dest_ips</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Parse IP to number as u8 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num_ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">str</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Extract all 4 IPV4 fields advancing iterator parsing it to u8;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// Like 192 (first parse) and the subsequent: 168, 1, 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">16</span><span class="o">..=</span><span class="mi">19</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">packet</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_ip</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><p>It is also a good time to dbg!() the object so we know how a packet looks like! Feel free to try.</p>
<h3 id="the-icmp-packet" class="group relative">
  The ICMP Packet

  
      <a href="#the-icmp-packet" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h3><p>ICMP packet has a structure like this:</p>
<table>
  <thead>
      <tr>
          <th><strong>Offset (Bytes)</strong></th>
          <th><strong>Field</strong></th>
          <th><strong>Size</strong></th>
          <th><strong>Value</strong></th>
          <th><strong>Description</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>Type</td>
          <td>1 byte</td>
          <td>8</td>
          <td>Error type</td>
      </tr>
      <tr>
          <td>1</td>
          <td>Code</td>
          <td>1 byte</td>
          <td>0</td>
          <td>Error code</td>
      </tr>
      <tr>
          <td>2-3</td>
          <td>Checksum</td>
          <td>2 bytes</td>
          <td>To be calculated</td>
          <td>Checks if the packet isn&rsquo;t corrupted.</td>
      </tr>
      <tr>
          <td>4-5</td>
          <td>Identification</td>
          <td>2 bytes</td>
          <td>0x12/0x34</td>
          <td>Unique packet ID</td>
      </tr>
      <tr>
          <td>6-7</td>
          <td>Sequence Number</td>
          <td>2 bytes</td>
          <td>0x00/0x01</td>
          <td>Identifies individual packets in a session</td>
      </tr>
  </tbody>
</table>
<p>Now, in order to send our packet, we need to craft the ICMP packet itself! as well as calculate it’s checksum, so first we set our ICMP packet right before our IP definition on packet:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="cm">/* After set our IP code to packet */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ICMP Header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">         </span><span class="c1">// Type (Echo Request)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// packet[21] = 0;      // Code (Omitted, already 0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">todo!</span><span class="p">();</span><span class="w">   </span><span class="c1">//  Checksum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">todo!</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12</span><span class="p">;</span><span class="w">      </span><span class="c1">// Identifier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x34</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w">      </span><span class="c1">// Sequence Number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">packet</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line hl"><span class="cl"><span class="w">    </span><span class="c1">// Uses each destination IP address to until an request is successfully completed
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">dest_ips</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">        </span><span class="c1">// Parse IP to number as u8 
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num_ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">str</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><p>And calculate it’s checksum:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="k">mod</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="cm">/* After resolve_host() definition */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// Makes data into 2 bytes words, sum and invert them (NOT bit operation)
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 
</span></span></span><span class="line"><span class="cl"><span class="sd">/// [0x32, 0x00, 0x49, 0x30, [...]] -&gt; Raw Vec (u8 representation)
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 
</span></span></span><span class="line"><span class="cl"><span class="sd">/// [0x3200, 0x4930, 0x0001, 0x3842] -&gt; What we need
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">calc_checksum</span><span class="p">(</span><span class="n">data</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">u16</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// u32 so we can handle u16 bit overflow later
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="k">u32</span><span class="p">;</span><span class="w"> </span><span class="c1">// -&gt; 00000000 00000000 00000000 00000000;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// -1 Set odd handling, as we step 2 each time when an odd is found 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// the conditional is not true because it&#39;s value is equal to data.len() - 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Get 1 byte and shift it by 1 byte.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// Now we got &#34;1 byte extra space&#34; since we&#39;re dealing with an u8 as cast it to u32 in the process;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// Ex: Our u8 00000010 becomes 0000000 00000000 00000010 00000000 (u32 bits aligned)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// This way we just free the needed space to block another byte into it (data[i+1]).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// &#34;|&#34; Add the bits so as we already got the free byte (8 bits),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// we can just add them casting to u32 as only same types are allowed to sum.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">word</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Odd buffer handling
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Strip zeroed bytes from u32 sum until a valid u16 is set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Finally, this is an operation to make our u32 with possible overflow 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// to fit into u16 correctly, following the checksum algorithm.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Sum lower 16 bits with overflow (if present)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">!</span><span class="n">sum</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The checksum algorithm and it’s bytes transformations is a topic which is worthy a dedicated article just for itself; I tried to let some comments in the code to clarify, but it is interesting for the people who wants to really understand what’s going on to search for the algorithm itself as well as how Rust deal with bytes.</p>
<p>Now it is also a good time to set some tests, so we can check for the algorithm correctness:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="k">mod</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="cm">/* After calc_checksum() definition */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[cfg(test)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// Assert checksum of a dummy ICMP packet is correct.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="sd">/// 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="cp">#[test]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">pair_checksum</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mh">0x08</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x12</span><span class="p">,</span><span class="w"> </span><span class="mh">0x34</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span>: <span class="kt">u16</span> <span class="o">=</span><span class="w"> </span><span class="mh">0xE5CA</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">calc_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cp">#[test]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">odd_checksum</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Same as above but with additional 0x23 on final.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mh">0x08</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x12</span><span class="p">,</span><span class="w"> </span><span class="mh">0x34</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x23</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span>: <span class="kt">u16</span> <span class="o">=</span><span class="w"> </span><span class="mh">0xC2CA</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">calc_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><p>Finally mapping our objects with it:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line hl"><span class="cl"><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">                          </span><span class="c1">// TTL
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                          </span><span class="c1">// Protocol (ICMP)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">ip_checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calc_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">20</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ip_checksum</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w">  </span><span class="c1">// High Byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ip_checksum</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="c1">// Low Byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">		
</span></span></span><span class="line hl"><span class="cl"><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">my_ip_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_ip</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">my_num_ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_ip_str</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">		
</span></span></span><span class="line hl"><span class="cl"><span class="w">		</span><span class="c1">// Set local IP Address to packet
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">12</span><span class="o">..=</span><span class="mi">15</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">		    </span><span class="n">packet</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_num_ip</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">		</span><span class="p">}</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">		
</span></span></span><span class="line hl"><span class="cl"><span class="w">		</span><span class="c1">// ICMP Header
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">         </span><span class="c1">// Type (Echo Request)
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="c1">// packet[21] = 0;      // Code (Omitted, already 0)
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="c1">// packet[22] = 0;      //  Checksum (u16)
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="c1">// packet[23] = 0;
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12</span><span class="p">;</span><span class="w">      </span><span class="c1">// Identifier
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x34</span><span class="p">;</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w">      </span><span class="c1">// Sequence Number
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="kd">let</span><span class="w"> </span><span class="n">icmp_checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calc_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="p">[</span><span class="mi">20</span><span class="o">..=</span><span class="mi">27</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">icmp_checksum</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w">  </span><span class="c1">// High Byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">		</span><span class="n">packet</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">icmp_checksum</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="c1">// Low Byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><h3 id="allowing-icmp-ttl-expired-packet-on-windows" class="group relative">
  Allowing ICMP TTL Expired Packet on Windows

  
      <a href="#allowing-icmp-ttl-expired-packet-on-windows" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h3><p>By default, Windows 11 blocks ICMP TTL expired responses, to enable it so we can receive our trace packets, you can follow the above tutorial:</p>
<ul>
<li><strong>Open Windows Firewall with Advanced Security</strong>
<ul>
<li>Go to the Start menu, search for &ldquo;Windows Firewall with Advanced Security,&rdquo; and open it.</li>
<li>Alternatively, press <code>Win + R</code>, type <code>wf.msc</code>, and press Enter.</li>
</ul>
</li>
<li><strong>Navigate to Inbound Rules</strong>
<ul>
<li>In the left pane, click &ldquo;Inbound Rules.&rdquo;</li>
</ul>
</li>
<li><strong>Create a New Rule</strong>
<ul>
<li>In the right pane, under the &ldquo;Actions&rdquo; section, click &ldquo;New Rule.&rdquo;</li>
</ul>
</li>
<li><strong>Select Rule Type</strong>
<ul>
<li>Choose &ldquo;Custom&rdquo; as the rule type and click &ldquo;Next.&rdquo;</li>
</ul>
</li>
<li><strong>Specify Programs</strong>
<ul>
<li>Select &ldquo;All programs&rdquo; (this rule applies to network traffic, not a specific program) and click &ldquo;Next.&rdquo;</li>
</ul>
</li>
<li><strong>Configure Protocol and ICMP Settings</strong>
<ul>
<li>In the &ldquo;Protocol type&rdquo; dropdown, select &ldquo;ICMPv4.&rdquo;</li>
<li>Click &ldquo;Customize&rdquo; next to &ldquo;ICMP settings.&rdquo;</li>
<li>In the &ldquo;Customize ICMP Settings&rdquo; dialog, select &ldquo;Specific ICMP types.&rdquo;</li>
<li>Check the box for &ldquo;Time Exceeded (Type 11).&rdquo;</li>
<li>Click &ldquo;OK&rdquo; to close the dialog, then click &ldquo;Next.&rdquo;</li>
</ul>
</li>
<li><strong>Define the Scope</strong>
<ul>
<li>On the &ldquo;Scope&rdquo; page, specify which IP addresses this rule applies to. For most cases, leave it as &ldquo;Any IP address&rdquo; for both local and remote addresses, then click &ldquo;Next.&rdquo;</li>
</ul>
</li>
<li><strong>Set the Action</strong>
<ul>
<li>Select &ldquo;Allow the connection&rdquo; and click &ldquo;Next.&rdquo;</li>
</ul>
</li>
<li><strong>Choose Network Profiles</strong>
<ul>
<li>Select the profiles where this rule should apply (e.g., &ldquo;Domain,&rdquo; &ldquo;Private,&rdquo; &ldquo;Public&rdquo;). For general use, check all profiles, then click &ldquo;Next.&rdquo;</li>
</ul>
</li>
<li><strong>Name the Rule</strong>
<ul>
<li>Enter a name like &ldquo;Allow ICMP Type 11&rdquo; and, optionally, add a description for reference.</li>
<li>Click &ldquo;Finish.&rdquo;</li>
</ul>
</li>
</ul>
<h2 id="sending-our-packet" class="group relative">
  Sending Our Packet

  
      <a href="#sending-our-packet" 
         class="anchor-link opacity-0 group-hover:opacity-100 transition-opacity ml-2 text-gray-500 no-underline"
         aria-label="Link to this section">
        #
      </a>
  
  
</h2><p>Wow, that was a lot of work!! We’re getting near to the end of the article and it’s time to finally send our hand-wrote packets, hoping routers increasing our TTL until our target are found; For this we’ll make a little change on the index loop, iterating over all <em>valid IPs</em> and for each <em>valid IP</em> we’ll hop on routers by increasing the TTL by adding this to it’s inner code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="cm">/* After set our IP code to packet, on address loop */</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">    </span><span class="c1">// Extract all 4 IPV4 fields advancing iterator parsing it to u8;
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Like 192 (first parse) and the subsequent: 168, 1, 1
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">16</span><span class="o">..=</span><span class="mi">19</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">        </span><span class="n">packet</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_ip</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">ttl</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..=</span><span class="mi">30</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">// Set TTL on IP header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">      </span><span class="n">packet</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ttl</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">// Effectivelly send our Packet, 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">      </span><span class="c1">// blocking current thread until a response is read or TTL end is reached.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">      </span><span class="n">socket</span><span class="p">.</span><span class="n">set_read_timeout</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">socket</span><span class="p">.</span><span class="n">send_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">SockAddr</span>::<span class="n">from</span><span class="p">(</span><span class="n">SocketAddr</span>::<span class="n">new</span><span class="p">(</span><span class="n">dest_ip</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Tracing with TTL: </span><span class="si">{ttl}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">// 56 bytes buffer - High buffer on convential values (56 bytes on TTL outlive)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span>: <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="mi">512</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">MaybeUninit</span>::<span class="n">uninit</span><span class="p">();</span><span class="w"> </span><span class="mi">512</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><p>Above we prepare a socket with 521 bytes of length and a timeout, meaning when we don’t receive a packet in 5 seconds, we emit an error and try again. It is initialized as Uninit because socket requires it, there’s no data in our buffer yet so we lie on this Rust API.</p>
<p>Now we create a match in our received socket data with it’s recv_from() function:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">      </span><span class="c1">// Effectivelly send our Packet, 
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">      </span><span class="c1">// blocking current thread until a response is read or TTL end is reached.
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">      </span><span class="n">socket</span><span class="p">.</span><span class="n">set_read_timeout</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">      </span><span class="n">socket</span><span class="p">.</span><span class="n">send_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">SockAddr</span>::<span class="n">from</span><span class="p">(</span><span class="n">SocketAddr</span>::<span class="n">new</span><span class="p">(</span><span class="n">dest_ip</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">      </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Tracing with TTL: </span><span class="si">{ttl}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">
</span></span></span><span class="line hl"><span class="cl"><span class="w">      </span><span class="c1">// 56 bytes buffer - High buffer on convential values (56 bytes on TTL outlive)
</span></span></span><span class="line hl"><span class="cl"><span class="c1"></span><span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span>: <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="mi">512</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">MaybeUninit</span>::<span class="n">uninit</span><span class="p">();</span><span class="w"> </span><span class="mi">512</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">match</span><span class="w"> </span><span class="n">socket</span><span class="p">.</span><span class="n">recv_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nb">Ok</span><span class="p">((</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">sender</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Received </span><span class="si">{size}</span><span class="s"> bytes from </span><span class="si">{sender:?}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="c1">// Responses generally are 56 (Time Exceed - IP Header/ICMP 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">              </span><span class="c1">// of sender and original IP Header) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">              </span><span class="c1">// or 28 (Success, IPHeader/ICMP packet of sender).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">              </span><span class="kd">let</span><span class="w"> </span><span class="n">received_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="n">std</span>::<span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                      </span><span class="n">buffer</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                      </span><span class="n">size</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="kd">let</span><span class="w"> </span><span class="n">received_ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_sender_ip</span><span class="p">(</span><span class="o">&amp;</span><span class="n">received_data</span><span class="p">[</span><span class="mi">12</span><span class="o">..=</span><span class="mi">15</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="c1">// Received ICMP type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">              </span><span class="kd">let</span><span class="w"> </span><span class="n">icmp_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">received_data</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="n">icmp_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;TTL: </span><span class="si">{ttl}</span><span class="s"> on </span><span class="si">{received_ip}</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="c1">// Adjust by your flavor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                  </span><span class="n">std</span>::<span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Reached destiny: </span><span class="si">{received_ip}</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ErrorKind</span>::<span class="n">WouldBlock</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	          </span><span class="o">||</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ErrorKind</span>::<span class="n">TimedOut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="fm">eprintln!</span><span class="p">(</span><span class="s">&#34;TTL=</span><span class="si">{ttl}</span><span class="s"> Timeout - No Response.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><p>Here we match the results from blocking recv_from(), if the data is successfully sent to our socket, we verify if it is a TTL outlive error (type 11), if not, we found our target. The received_data variable is a reader of our (hopefully) received buffer and as read incoming network buffers are always a unsafe action we set it as it is.</p>
<p>Finally, we set our last function: an util to read the router’s IPs whose are returned to us:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="p">[</span><span class="k">mod</span><span class="p">.</span><span class="n">rs</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w"> </span><span class="cm">/* Before Tests */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">parse_sender_ip</span><span class="p">(</span><span class="n">ip</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">str_ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="n">ip</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">str_ip</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to_string</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Remove last &#39;.&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">str_ip</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">str_ip</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">[</span><span class="o">..</span><span class="p">.]</span><span class="w">
</span></span></span></code></pre></div><p>And finally, it is done! We’ve created our own packets and used a cool raw socket to send them, now we can just run the application with:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cargo run -- <span class="o">[</span>domain<span class="o">]</span>
</span></span></code></pre></div><p>And see something like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Tracing route to <span class="o">[</span>google.com<span class="o">](</span>http://google.com/<span class="o">)</span>...
</span></span><span class="line"><span class="cl">ips: <span class="o">[</span>142.251.128.238<span class="o">]</span>
</span></span><span class="line"><span class="cl">my_ip: 10.0.0.111
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">1</span>
</span></span><span class="line"><span class="cl">Received <span class="m">56</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">1</span> on 0.0.1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">2</span>
</span></span><span class="line"><span class="cl">Received <span class="m">56</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">2</span> on 39.121.208
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">3</span>
</span></span><span class="line"><span class="cl">Received <span class="m">56</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">3</span> on 201.45.236
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">4</span>
</span></span><span class="line"><span class="cl">Received <span class="m">56</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">4</span> on 201.45.185
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">5</span>
</span></span><span class="line"><span class="cl">Received <span class="m">56</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">5</span> on 248.108.29
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">6</span>
</span></span><span class="line"><span class="cl">Received <span class="m">56</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">6</span> on 150.1.176
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">7</span>
</span></span><span class="line"><span class="cl">Received <span class="m">96</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">7</span> on 250.162.224
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">8</span>
</span></span><span class="line"><span class="cl">Received <span class="m">56</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">8</span> on 170.226.225
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">9</span>
</span></span><span class="line"><span class="cl">Received <span class="m">56</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">11</span>
</span></span><span class="line"><span class="cl">TTL: <span class="m">9</span> on 85.251.13
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Tracing with TTL: <span class="m">10</span>
</span></span><span class="line"><span class="cl">Received <span class="m">28</span> bytes from SockAddr <span class="o">{</span> ss_family: 2, len: <span class="m">16</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">icmp_type: <span class="m">0</span>
</span></span><span class="line"><span class="cl">Reached destiny: 251.128.238
</span></span></code></pre></div><p>So we’re done, our tracerouter from SCRATCH is working! Thank you for consuming this content; The original repository can be found here:</p>
<p><a href="https://github.com/FromScratchR/tracers">https://github.com/FromScratchR/tracers</a></p>
</div>
  
    <div class="mt-16">


<div class="giscus"></div>

<script src="https://giscus.app/client.js"
        data-repo="wnccys/blog"
        data-repo-id="R_kgDOQcA0BA"
        data-category="Announcements"
        data-category-id="DIC_kwDOQcA0BM4Cy7xQ"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="catppuccin_mocha"
        data-lang="pt"
        crossorigin="anonymous"
        async>
</script></div>
  
</article>
      </div>
    </main><footer class="left-0 bottom-0 w-full bg-base px-page-gutter">
  <div class="flex justify-center items-center h-footer-height">
    <div
      class="flex flex-row w-full max-w-content justify-between italic gap-3"
    >
      <nav>
        <a href="//localhost:1313//index.xml"
          ><svg
            width="18px"
            height="18px"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke-width="1.5"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.87 0 14.25 6.38 14.25 14.25v.75M6 18.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"
            />
          </svg>
        </a>
      </nav>
      <span class="text-muted hidden md:block">
        &copy;
        2025
      </span>
      <div id="header-theme-button">
        <svg
          id="dark_mode_btn"
          class="hidden toolbox-btn"
          width="18px"
          height="18px"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z"
          />
        </svg>
        <svg
          id="light_mode_btn"
          class="hidden toolbox-btn"
          width="18px"
          height="18px"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z"
          />
        </svg>
      </div>
    </div>
  </div>
</footer>


<button
    id="to-top-button"
    onclick="goToTop()"
    title="Go To Top"
    style="
        position: fixed; 
        bottom: 2rem; 
        right: 2rem; 
        z-index: 50; 
        width: 2.5rem; 
        height: 2.5rem; 
        border-radius: 9999px; 
        background-color: #060809; /* Special Black xD */
        color: white; 
        font-size: 1.25rem; 
        font-weight: bold; 
        border: none; 
        cursor: pointer;
        display: none; /* Hidden by default */
        opacity: 0; 
        transition: opacity 0.3s ease-in-out;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    "
>
    &uarr;
</button>

<script>
    var toTopButton = document.getElementById("to-top-button");

    window.onscroll = function () {
        
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            
            
            toTopButton.style.display = "block";
            
            
            setTimeout(() => {
                toTopButton.style.opacity = "1";
            }, 10);
            
        } else {
            
            toTopButton.style.opacity = "0";
            
            
            setTimeout(() => {
                if (toTopButton.style.opacity === "0") { 
                    toTopButton.style.display = "none";
                }
            }, 300);
        }
    };

    function goToTop() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
</script></body>
</html>
